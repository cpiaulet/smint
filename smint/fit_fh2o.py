#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Oct 14 08:37:47 2020

@author: caroline

Estimate water mass fraction from the mass and radius of a planet
assuming a rock+water mix, using the Zeng et al. 2016 grid

Utilities functions
"""

# Import modules ---------- 
import numpy as np
from scipy.interpolate import RegularGridInterpolator
import emcee
import corner
from astropy.io import ascii as aioascii
from astropy import table


#%% utilities for interpolation

def find_radius_fh2o(t=None, interp=None, mass=10., fh2o=10.):
    """
    Given a planet mass (in Earth masses) and a h2o mass fraction (%),
    get the best-matching planet radius (in Earth radii)
    """
    if interp is None:
        interp = make_interpolator_fh2o(t)
    r_earth = interp((fh2o,mass), method='linear')
    return r_earth


def make_interpolator_fh2o(t):
    """
    Takes as an input t the table of rock-h2o mix
    make an interpolator for the planet radius as a function of 
    ['Mass', 'fh2o']
    """
    
    # make array of f_h2o_pc and planet radius values
    f_h2o_pc = []
    R_list = []
    for c in t.columns[1:]:
        s = c.split('%')
        f_h2o_pc.append(float(s[0]))
        R_list.append(np.array(t[c]))
    f_h2o_pc = np.array(f_h2o_pc)
    
    Mass_oplus = np.array(t['Mass'])
    
    R_array = np.array(R_list)
    interpolator = RegularGridInterpolator((f_h2o_pc, Mass_oplus,), 
                                            R_array, bounds_error=False)
    return interpolator



#%% emcee functions

def lnlike(theta, true_rad, true_rad_err, interp):
    """
    Log-likelihood function for emcee fit
    """
    
    fh2o, mass = theta 
    
    # estimate interpolated radius for these params
    radius = find_radius_fh2o(t=None, interp=interp, mass=mass, fh2o=fh2o)
    return -0.5*(((true_rad-radius)/true_rad_err)**2)

def lnprior(theta, mass_mu, mass_err):
    """
    Log-prior (using known mass distri and uniform in fh2o)
    """
    fh2o, mass = theta

    if (fh2o < 0.) or (fh2o > 100.):
        return -np.inf
    if (mass < 0.0625) + (mass > 32.):
        return -np.inf

    return -0.5 *(((mass_mu - mass)/mass_err)**2.)

def lnprob(theta, true_rad, true_rad_err, interp, mass_mu, mass_err):
    """
    Log-probability function
    """
    lp = lnprior(theta, mass_mu, mass_err) 
    if not np.isfinite(lp):
        return -np.inf
    else:
        return lp + lnlike(theta, true_rad, true_rad_err, interp)
    

#%% run interpolator MCMC

def run_fit(params, interpolator):
    """
    Run the emcee fit using the previously-set up priors and params
    Interpolator: generated using make_interpolator_fh2o()
    returns the emcee sampler
    """
    
    print("\nSetting up the sampler...")
    sampler = emcee.EnsembleSampler(params["nwalkers"], params["ndim"], lnprob,
                                    args=(params["Rp_earth"],params["err_Rp_earth"],
                                          interpolator, params["Mp_earth"],
                                          params["err_Mp_earth"]))
    
    print("\nRunning the emcee fit...")
    sampler.run_mcmc(params["pos0"], params["nsteps"])
    
    if params["save"]:
        print("\nSaving the results...")
        np.save(params["outputdir"]+params["fname"]+'_chains.npy', sampler.chain)
    
    return sampler


#%% post-processing 
    
def calc_constraints(samples, params, more_percentiles=[15.9, 50., 84.1]):
    """
    Build astropy table of parameter constraints
    
    samples: flattened samples generated by emcee sampler (shape=(nsamp, ndim))
    params: fit params
    more percentiles: list of additional percentiles to calculate and return
    
    The table is printed, returned and saved to a csv file if params["save"]
    """
    medians = np.median(samples, axis=0)
    upper_lims = np.percentile(samples, 84.1, axis=0)
    lower_lims = np.percentile(samples, 15.9, axis=0)
    p1sig = upper_lims - medians
    m1sig = lower_lims - medians
    
    t = table.Table([params["labels"], medians, p1sig, m1sig], 
                    names=("Parameter", "Median", "+1sigma", "-1sigma"))
    
    for perc in more_percentiles:
        colname = str(int(perc*100.)/100.)+"th perc."
        t[colname] = np.percentile(samples, perc, axis=0)
    
    print("\nTable of parameter constraints:\n")
    print(t)

    if params["save"]:
        aioascii.write(t, params["outputdir"]+params["fname"]+'_constraints.csv', overwrite=True)
    return t

def plot_corner(samples, params, plot_datapoints=False, smooth=1.,
                        quantiles=[0.16, 0.5, 0.84], title_kwargs={'fontsize':14},
                        hist_kwargs={"linewidth":3}, rg=None, 
                        show_titles=True, levels=(0.393,0.865,0.989), **kwargs):
    """
    Corner plot for an emcee fit of the water mass fraction that matches
    the observed planet params
    
    samples: generated by emcee sampler
    params: fit params
    other args: args for the corner function
    
    Returns the figure with the corner plot 
    """
    hist_kwargs["color"] = params["hist_color"]
    color = params["hist_color"]
    fig = corner.corner(samples, labels=params["labels"], 
                        plot_datapoints=plot_datapoints, smooth=smooth,
                        show_titles=show_titles, quantiles=quantiles,
                        title_kwargs=title_kwargs, color=color,
                        hist_kwargs=hist_kwargs, range=rg, 
                        levels=levels, **kwargs)
    return fig


